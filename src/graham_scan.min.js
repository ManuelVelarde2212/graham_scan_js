function ConvexHullGrahamScan() {
    this.anclaPunto = undefined;
    this.reversa = false;
    this.puntos = [];
}

ConvexHullGrahamScan.prototype = {

    constructor: ConvexHullGrahamScan,

    Punto: function (x, y) {
        this.x = x;
        this.y = y;
    },

    _encontrarAnguloPolar: function (a, b) {
        var ONE_RADIAN = 57.295779513082;
        var deltaX, deltaY;

        //si los puntos no est치n definidos, devuelve un 치ngulo de diferencia cero.
        if (!a || !b) return 0;

        deltaX = (b.x - a.x);
        deltaY = (b.y - a.y);

        if (deltaX == 0 && deltaY == 0) {
            return 0;
        }

        var angulo = Math.atan2(deltaY, deltaX) * ONE_RADIAN;

        if (this.reversa){
            if (angulo <= 0) {
                angulo += 360;
            }
        }else{
            if (angulo >= 0) {
                angulo += 360;
            }
        }

        return angulo;
    },

    a침adirPunto: function (x, y) {
        // Buscar una nueva ancla
        var newAncla =
            (this.anclaPunto === undefined) ||
            ( this.anclaPunto.y > y ) ||
            ( this.anclaPunto.y === y && this.anclaPunto.x > x );

        if ( newAncla ) {
            if ( this.anclaPunto !== undefined ) {
                this.puntos.push(new this.Punto(this.anclaPunto.x, this.anclaPunto.y));
            }
            this.anclaPunto = new this.Punto(x, y);
        } else {
            this.puntos.push(new this.Punto(x, y));
        }
    },

    _ordenarPuntos: function () {
        var self = this;

        return this.puntos.sort(function (a, b) {
            var polarA = self._encontrarAnguloPolar(self.anclaPunto, a);
            var polarB = self._encontrarAnguloPolar(self.anclaPunto, b);

            if (polarA < polarB) {
                return -1;
            }
            if (polarA > polarB) {
                return 1;
            }

            return 0;
        });
    },

    _checkPuntos: function (p0, p1, p2) {
        var difAngulo;
        var cwAngulo = this._encontrarAnguloPolar(p0, p1);
        var ccwAngulo = this._encontrarAnguloPolar(p0, p2);

        if (cwAngulo > ccwAngulo) {

            difAngulo = cwAngulo - ccwAngulo;

            return !(difAngulo > 180);

        } else if (cwAngulo < ccwAngulo) {

            difAngulo = ccwAngulo - cwAngulo;

            return (difAngulo > 180);

        }

        return true;
    },

    getHull: function () {
        var puntosHull = [],
            puntos,
            puntosLength;

        this.reversa = this.puntos.every(function(point){
            return (point.x < 0 && point.y < 0);
        });

        puntos = this._ordenarPuntos();
        puntosLength = puntos.length;

        // Si hay menos de 3 puntos, unir estos puntos crea un casco correcto.
        if (puntosLength < 3) {
            puntos.unshift(this.anclaPunto);
            return puntos;
        }

        // mueve los dos primeros puntos a la matriz de salida
        puntosHull.push(puntos.shift(), puntos.shift());

        // el escaneo se repite hasta que no hay puntos c칩ncavos presentes.
        while (true) {
            var p0,
                p1,
                p2;

            puntosHull.push(puntos.shift());

            p0 = puntosHull[puntosHull.length - 3];
            p1 = puntosHull[puntosHull.length - 2];
            p2 = puntosHull[puntosHull.length - 1];

            if (this._checkPuntos(p0, p1, p2)) {
                puntosHull.splice(puntosHull.length - 2, 1);
            }

            if (puntos.length == 0) {
                if (puntosLength == puntosHull.length) {
                    // verifica si hay un caso de borde de puntoAncla duplicado, si no se encuentra, agrega el puntoAncla como el primer elemento.
                    var ap = this.anclaPunto;
                    // elimina cualquier elemento indefinido en la matriz de puntos del casco.
                    puntosHull = puntosHull.filter(function(p) { return !!p; });
                    if (!puntosHull.some(function(p){
                            return(p.x == ap.x && p.y == ap.y);
                        })) {
                        puntosHull.unshift(this.anclaPunto);
                    }
                    return puntosHull;
                }
                puntos = puntosHull;
                puntosLength = puntos.length;
                puntosHull = [];
                puntosHull.push(puntos.shift(), puntos.shift());
            }
        }
    }
};

// EXPORTAR

if (typeof define === 'function' && define.amd) {
    define(function() {
        return ConvexHullGrahamScan;
    });
}
if (typeof module !== 'undefined') {
    module.exports = ConvexHullGrahamScan;
}


